# Project Python dependencies (minimal list inferred from code)
fastapi
uvicorn
pandas
requests
ccxt
vaderSentiment
python-dotenv
google-generativeai

# plan_analyzer.py
import re
import json
from typing import List, Dict
from dataclasses import dataclass, asdict
from pydantic import ValidationError
import google.generativeai as genai
import os
from .schema import Plan, GOOD_THRESH, BAD_THRESH
from dotenv import load_dotenv


# ---------------- Default Plan JSON ---------------- #
DEFAULT_JSON = {
    "name": "Auto_Expert",
    "regime": "auto",
    "direction_bias": "neutral",
    "universe": ["BTC", "ETH", "SOL"],  # renamed to match schema
    "custom_rules": [],
    "gates": {
        "trend": {"ema_short": 50, "ema_long": 200, "adx_min": 20},
        "range": {"adx_max": 20, "bb_bw_pct_max": 0.30},
        "breakout": {"donchian_n": 20, "min_vol_mult": 1.5, "adx_rising": True},
        "support": {"atr_mult": 0.8, "rsi_min": 40},
        "sentiment": "AUTO"
    },
    "weighting": {
        "mode": "composite",
        "coeffs": {"trend": 0.35, "momentum": 0.35, "volume": 0.15, "sentiment": 0.15},
        "tilt_sentiment_pct": 0.10
    },
    "rebalance": {"cadence": "weekly", "band_pp": 5.0, "turnover_max": 0.15},
    "risk": {
        "max_weight": 0.40,
        "hard_cap": 0.50,
        "slippage_max_bps": 80,
        "order_max_usd": 2000,
        "cooldown_hours": 6
    },
    "execution": {"chunk_usd": 2000, "use_yield": False},
    "sentiment_cfg": {"good_threshold": GOOD_THRESH, "bad_threshold": BAD_THRESH, "shock_delta_24h": 0.50}
}


# ---------------- Dataclass (Optional Wrapper) ---------------- #
@dataclass
class PlanDataclass:
    regime: str
    direction_bias: str
    universe: List[str]
    gates: dict
    custom_rules: List[str]
    weighting: dict
    rebalance: dict
    risk: dict
    execution: dict
    sentiment_cfg: dict

    def to_dict(self) -> dict:
        return asdict(self)


# ---------------- Regex-based fallback ---------------- #
def build_plan_json_from_text(user_text: str) -> dict:
    """
    Quick parser for extracting obvious fields from user text.
    Falls back to DEFAULT_JSON for everything else.
    """
    t = user_text.lower()
    plan = {**DEFAULT_JSON}

    # universe detection
    uni = []
    for k in ["btc", "eth", "sol", "avax", "matic", "xrp"]:
        if re.search(rf"\b{k}\b", t):
            uni.append(k.upper())
    if uni:
        plan["universe"] = uni

    # direction bias
    if "bullish" in t:
        plan["direction_bias"] = "bullish"
    elif "bearish" in t:
        plan["direction_bias"] = "bearish"

    # regime hints
    for r in ["trend", "range", "breakout", "support"]:
        if r in t:
            plan["regime"] = r

    # custom rules
    rules = []
    if "price > 30d ma" in t or "above 30d" in t:
        rules.append("CLOSE>SMA(30)")
    m = re.search(r"rsi\s*>\s*([4-9]\d)", t)
    if m:
        rules.append(f"RSI(14)>{m.group(1)}")
    if "volume strong" in t:
        rules.append("VOLUME>1.5*VOL_SMA(20)")
    if "sentiment good" in t:
        rules.append("SENTIMENT>=GOOD")

    plan["custom_rules"] = rules
    return plan


# ---------------- Gemini-powered generator ---------------- #
def build_plan_with_gemini(user_text: str) -> dict:
    """
    Use Gemini to generate a structured Plan JSON.
    Falls back to regex parser if Gemini fails.
    """
    try:
        load_dotenv()
        genai.configure(api_key=os.environ["GOOGLE_API_KEY"])
    except Exception as e:
        # If Gemini not configured, fallback immediately
        return build_plan_json_from_text(user_text)

    plan_json_schema = Plan.model_json_schema()

    prompt_parts = [
    "You are an expert crypto trading strategist. "
    "The user will provide a natural language description of a strategy. "
    "Your job is to fill out a Plan JSON object that strictly conforms to the schema below. "
    "Important: if the user does not mention some fields, YOU must auto-populate them with the best-practice defaults "
    "from technical analysis and risk management. "
    "For example: always include trend gates with EMA(50/200) and ADX>20, breakout gates with Donchian(20), "
    "support with ATR(0.8) and RSI>40, weighting coeffs with trend/momentum=0.35 each, volume=0.15, sentiment=0.15, etc. "
    "Never leave required fields as null or None unless the schema forces it. "
    "If the user gives incomplete info, intelligently complete the plan using robust defaults."
    "\n\nJSON Schema:\n"
    f"{json.dumps(Plan.model_json_schema(), indent=2)}\n\n"
    f"User's Strategy Description: \"{user_text}\"\n\n"
    "Output only the JSON object, no explanations."
]

    model = genai.GenerativeModel('gemini-2.5-flash')

    try:
        response = model.generate_content(
            prompt_parts,
            generation_config={"response_mime_type": "application/json"}
        )
        raw_json_output = response.text
        plan_data = json.loads(raw_json_output)

        # Validate against Pydantic Plan schema
        validated_plan = Plan.model_validate(plan_data)
        return validated_plan.model_dump()

    except Exception as e:
        # Fallback: regex parser
        return build_plan_json_from_text(user_text)


# ---------------- Feature Analyzer ---------------- #
def analyze_features(plan_json: dict) -> dict:
    """
    Suggest what features/indicators will be needed for this plan.
    """
    return {
        "assets": plan_json.get("universe", []),
        "features": [
            "OHLCV", "SMA/EMA", "RSI/StochRSI", "MACD", "ADX/DI",
            "ATR", "Bollinger/Keltner", "Donchian", "OBV/CMF/MFI",
            "VWAP", "Sentiment"
        ],
        "lookback_days": 540
    }
